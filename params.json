{"name":"Insideout","tagline":"A tool to develop ready-to-use python repositories.","body":"# The *insideout* approach to Python packaging\r\n\r\n> Why aren't the files inside a Python package the first thing we see when we look at its github repository?\r\n\r\n*insideout* is a tool to help you postpone the ugliness of your Python\r\nrepository from the viewer's eyes, for example by moving away those ugly\r\nlong lists of configuration files that can be seen in almost every open-source\r\nrepository.\r\n\r\nTake a look at these notorious monstrosities:\r\n\r\n* [pypa/pip 8.0.1](https://github.com/pypa/pip/tree/024cfe17e6685483a5a6abfc8983c086267a5a47) ➙ 15 residual files\r\n* [mitsuhiko/flask 0.10](https://github.com/mitsuhiko/flask/tree/3b9574fec988fca790ffe78b64ef30b22dd3386a) ➙ 16 residual files\r\n* [jkbrzt/httpie 0.9.3](https://github.com/jkbrzt/httpie/tree/47220763357f5a25cc535af5c4d2f4f092fb9abd) ➙ 18 residual files\r\n\r\nJust look at them: they are **ugly**. Right? There is something unatural to\r\nthe way the root directory of those repositories looks like.\r\n\r\n## Installation\r\n\r\n*insideout* is pure Python code, 2 and 3 compatible. You can download this\r\nrepository from github and install it in your environment with:\r\n\r\n    $ python __dev__/setup.py install\r\n\r\nOr you can also go to PyPI and install from the latest version available their:\r\n\r\n    $ pip install insideout\r\n\r\n## Background\r\n\r\nSo, with the single design intention of avoiding as much ugliness as\r\ntechnically possible in the root directory of your repository, lets look at a\r\ntypical example and see what can be improved. Imagine you have the following\r\nsource tree:\r\n\r\n    $ tree\r\n    .\r\n    ├── package/\r\n    │   ├── __init__.py         # could be in the root directory\r\n    │   ├── main.py             # could be in the root directory\r\n    │   └── tools.py            # could be in the root directory\r\n    ├── tests/              # ugly. should not be here\r\n    │   └── (...)\r\n    ├── tox.ini             # ugly. should not be here\r\n    ├── LICENSE.txt         # ugly. should not be here\r\n    ├── setup.py            # ugly. should not be here\r\n    └── README.md           # ok. Github can generate an HTML page from this.\r\n\r\nBasically, what is about to be explained comes down to this:\r\n\r\n> A file on the root directory is ugly if it is not absolutely needed when **making use of** the package.\r\n\r\nIn commerce, prospects are one thing and clients are another. With our\r\nopen-source repositories a similar distinction can be made about the python\r\ndevelopers who look at them: the ones who use our code are one thing and the\r\nones who further contribute to it are another. Hence, the adjective *ugly*\r\nherein used, is analyzed from the first perspective only: the developer who\r\nat most **makes use of** your package, without any intentions of further\r\ndeveloping, testing or deploying it.\r\n\r\nThis tightens the interpretation of the adjective *ugly* to a point where\r\nthere isn't much margin for subjective thought. For example, from this\r\nperspective it is obvious that `license.txt` should be absolutely postponed\r\nfrom the viewer's eyes, simply because it is not needed to make use of the\r\ncode in the package. The same applies to the `tests` directory. If you want\r\nto focus the use of tests in your project, write about it on the `README`\r\nfile, for example. These types of entries on your repository root's are ugly\r\nand their observation should be postponed to a later moment.\r\n\r\nWith `insideout` we can pull the package source files to the root directory,\r\nand push all the residual testing/configuration files and folders away from\r\nsight. A folder called `__dev__` is created for this purpose:\r\n\r\n    $ insideout\r\n    $ tree\r\n    .\r\n    ├── __dev__/\r\n    │   ├── tests/              # ok. no longer ugly\r\n    │   ├── setup.py            # ok. no longer ugly\r\n    │   ├── tox.ini             # ok. no longer ugly\r\n    │   └── (...)               # remaining ugly files/folders went all here\r\n    ├── README.md             # ok. Github can generate an HTML page from this.\r\n    ├── __init__.py           # ok. explicitly observable, nice!\r\n    ├── main.py               # ok. explicitly observable, nice!\r\n    └── tools.py              # ok. explicitly observable, nice!\r\n\r\nIts almost the same as turning a t-shirt inside out. For example, the\r\n`README.md` was left behind in order to allow presenting an HTML page on\r\ngithub. There is also some caution in place to avoid moving the `.git`\r\nfolder. This resulting structure is reversible to the previous structure by\r\nre-executing the command `insideout`.\r\n\r\n## Workflow\r\n\r\nThe problem now, is that `setup.py` is not on a folder level immediatly\r\nabove to the package level, which makes it complicated to generate\r\ndistributions or install the package. This is solved in at least the\r\nfollowing two ways.\r\n\r\n#### `setup.py` fix\r\n\r\nIt is actually easy to solve the directory problem by the adding the\r\nfollowing code to the begging of your `setup.py` file:\r\n\r\n```python\r\nimport os\r\nimport shutil\r\n\r\nPACKAGE_NAME = '<...package name goes here>'\r\n\r\n_t = os.path.abspath(__file__)\r\ncwd = os.path.dirname(_t)\r\nif os.path.basename(cwd) == '__dev__':\r\n    os.chdir(cwd)\r\n    shutil.rmtree(PACKAGE_NAME, ignore_errors=True)\r\n    ignore_list = shutil.ignore_patterns('__dev__*', '.git*', 'env*', '.tox')\r\n    shutil.copytree('..', PACKAGE_NAME, ignore=ignore_list)\r\n```\r\n\r\nAnd that's it. That code enables the `setup.py` to work as expected from\r\nanywhere.\r\n\r\nFrom the root of the repository you can run these:\r\n\r\n    $ python __dev__/setup.py install\r\n    $ tox -c __dev__/tox.ini\r\n\r\nFrom inside __dev__ you can run these:\r\n\r\n    $ python setup.py install\r\n    $ tox\r\n\r\nEven if you reorganize your code in the classical testing/deployment focused\r\nstructure (where all the test configuration files, license, etc., are placed\r\nin the root directory of your repository) then this setup.py still works.\r\n\r\n#### (alternative) prefix `git` commands with `insideout`\r\n\r\nIf you don't want to touch in your `setup.py`, then, in order to maintain\r\nyour public version (the one accesible throught github) in the explicit\r\nform, you can work locally on your project with the *ugly* files on the root\r\ndirectory by preforming the following steps:\r\n\r\n1. Clone the intended git repository: `$ git clone <clone_url>`\r\n2. Swap files to the insideout style: `$ insideout`\r\n3. Prefix all `git` commands with *insideout*. Examples:\r\n    - `$ insideout git status`\r\n    - `$ insideout git add compiler.py`\r\n    - `$ insideout git commit -m \"adds compiler\"`\r\n    - `$ insideout git push origin master`\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}